// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib from "rescript/lib/es6/Stdlib.js";
import * as Nodefs from "node:fs";
import Archiver from "archiver";
import * as Nodeurl from "node:url";
import FastGlob from "fast-glob";
import * as Nodepath from "node:path";
import * as Stdlib_List from "rescript/lib/es6/Stdlib_List.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as Stdlib_Promise from "rescript/lib/es6/Stdlib_Promise.js";
import * as Primitive_string from "rescript/lib/es6/Primitive_string.js";

let dirname = Nodeurl.fileURLToPath(new URL(".", import.meta.url));

function findConfig(baseDir) {
  let candidates = [
    "rescript.json",
    "bsconfig.json"
  ];
  return Stdlib_Option.getOrThrow(candidates.map(configName => Nodepath.join(baseDir, configName)).find(prim => Nodefs.existsSync(prim)), "Could not find a ReScript config file (rescript.json or bsconfig.json) in the target directory.");
}

function toSourceEntries(sources) {
  let normalize = json => {
    switch (typeof json) {
      case "string" :
        return {
          dir: json,
          subdirs: true
        };
      case "object" :
        let subdirs = json.subdirs;
        let dir = json.dir;
        let tmp;
        tmp = typeof dir === "string" ? dir : ".";
        let tmp$1;
        tmp$1 = typeof subdirs === "boolean" ? subdirs : true;
        return {
          dir: tmp,
          subdirs: tmp$1
        };
      default:
        return Stdlib.panic("Invalid `sources` config in ReScript config file.");
    }
  };
  if (Array.isArray(sources)) {
    return sources.map(normalize);
  }
  switch (typeof sources) {
    case "string" :
    case "object" :
      return [normalize(sources)];
    default:
      return [];
  }
}

function collectFilesWithSuffix(baseDir, sourceDir, recursive, suffix) {
  let root = Nodepath.join(baseDir, sourceDir);
  if (!Nodefs.existsSync(root) || !Nodefs.statSync(root).isDirectory()) {
    return [];
  }
  let rel = Nodepath.relative(baseDir, root);
  let tail = "*" + suffix;
  let pattern = recursive ? rel + "/**/" + tail : rel + "/" + tail;
  return FastGlob.sync(pattern, {
    cwd: baseDir,
    absolute: true,
    onlyFiles: true,
    dot: false,
    followSymbolicLinks: true
  });
}

function uniqueSorted(list) {
  let l = Array.from(new Set(list));
  l.sort(Primitive_string.compare);
  return l;
}

function ensureParentDir(p) {
  let dir = Nodepath.dirname(p);
  if (!Nodefs.existsSync(dir)) {
    Nodefs.mkdirSync(dir, {
      recursive: true
    });
    return;
  }
  
}

async function createZip(baseDir, filesAbs, outPath) {
  let filesRel = filesAbs.map(f => Nodepath.relative(baseDir, f));
  return await new Promise((resolve, reject) => {
    let output = Nodefs.createWriteStream(outPath);
    let archive = Archiver("zip", {
      zlib: {
        level: 9
      }
    });
    output.on("close", () => resolve());
    archive.on("error", () => reject());
    archive.pipe(output);
    filesRel.forEach(rel => {
      archive.file(Nodepath.join(baseDir, rel), {
        name: rel
      });
    });
    archive.finalize();
  });
}

async function procudeDiffZip(baseDirArg, outArg) {
  let baseDir = Nodepath.isAbsolute(baseDirArg) ? baseDirArg : Nodepath.join(process.cwd(), baseDirArg);
  let cfgPath = findConfig(baseDir);
  let cfg = JSON.parse(Nodefs.readFileSync(cfgPath, "utf8"));
  let match;
  if (typeof cfg === "object" && cfg !== null && !Array.isArray(cfg)) {
    let sources = cfg.sources;
    if (sources !== undefined) {
      let suffix = cfg.suffix;
      let tmp;
      tmp = typeof suffix === "string" ? suffix : ".bs.js";
      match = [
        tmp,
        toSourceEntries(sources)
      ];
    } else {
      match = [
        ".bs.js",
        []
      ];
    }
  } else {
    match = [
      ".bs.js",
      []
    ];
  }
  let suffix$1 = match[0];
  console.log("=== Zipping files with suffix \"" + suffix$1 + "\"...");
  let files = match[1].flatMap(s => collectFilesWithSuffix(baseDir, s.dir, s.subdirs, suffix$1));
  let files$1 = uniqueSorted(files);
  if (files$1.length !== 0) {
    let resolvedOutPath = outArg !== undefined ? (
        Nodepath.isAbsolute(outArg) ? outArg : Nodepath.join(baseDir, outArg)
      ) : Nodepath.join(baseDir, "diff.zip");
    ensureParentDir(resolvedOutPath);
    try {
      await createZip(baseDir, files$1, resolvedOutPath);
    } catch (exn) {
      console.error("Failed to create zip file.");
      process.exit(1);
    }
    console.log("=== Created zip file: " + resolvedOutPath);
    console.log("=== Done.");
    return process.exit(0);
  }
  console.error("No files with suffix \"" + suffix$1 + "\" found in configured sources.");
  return process.exit(1);
}

let saveGeneratedJsUsageStr = "rescript-generated-js-diff save-generated-js <base-dir> [out-file]";

async function main() {
  let args = Stdlib_List.fromArray(process.argv.slice(2));
  if (args !== 0 && args.hd === "save-generated-js") {
    let args$1 = args.tl;
    if (Stdlib_List.length(args$1) >= 1) {
      let match;
      if (args$1 !== 0) {
        let match$1 = args$1.tl;
        let baseDir = args$1.hd;
        match = match$1 !== 0 ? (
            match$1.tl !== 0 ? Stdlib.panic("Usage: " + saveGeneratedJsUsageStr) : [
                baseDir,
                match$1.hd
              ]
          ) : [
            baseDir,
            undefined
          ];
      } else {
        match = Stdlib.panic("Usage: " + saveGeneratedJsUsageStr);
      }
      return await procudeDiffZip(match[0], match[1]);
    }
    
  }
  console.error("Usage: " + saveGeneratedJsUsageStr);
  return process.exit(1);
}

Stdlib_Promise.$$catch(main(), e => {
  console.error("Something went wrong", e);
  return process.exit(1);
});

export {
  dirname,
  findConfig,
  toSourceEntries,
  collectFilesWithSuffix,
  uniqueSorted,
  ensureParentDir,
  createZip,
  procudeDiffZip,
  saveGeneratedJsUsageStr,
  main,
}
/* dirname Not a pure module */
